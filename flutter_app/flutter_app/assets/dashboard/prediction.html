<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Next-Day Temperature Forecast Dashboard (LSTM)</title>
  <!-- TensorFlow.js -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js"></script>
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root { font-family: system-ui,-apple-system,BlinkMacSystemFont,sans-serif; }
    body { max-width: 1100px; margin: 0 auto; padding: 1rem; background: #f5f7fa; }
    h1 { font-size: 1.9rem; margin-bottom: 0.2rem; }
    .grid { display: grid; gap: 1rem; grid-template-columns: 2fr 1fr; }
    .card { background: white; border-radius: 1rem; padding: 1rem 1.25rem; box-shadow: 0 12px 36px -10px rgba(0,0,0,0.08); }
    .small { font-size: .85rem; color: #555; }
    .inline { display: flex; gap: .75rem; flex-wrap: wrap; }
    label { display: block; margin-bottom: .25rem; font-weight: 600; }
    input, select, textarea { width: 100%; padding: .5rem .6rem; border: 1px solid #d1d9e6; border-radius: .5rem; font-size: .9rem; }
    button { cursor: pointer; background: #6366f1; color: white; border: none; padding: .65rem 1rem; border-radius: .75rem; font-weight: 600; transition: all .15s; }
    button:hover { filter: brightness(1.08); }
    .feature-list { max-height: 220px; overflow: auto; border: 1px solid #e2e8f0; border-radius: .5rem; padding: .5rem; }
    .pill { background: #eef2ff; padding: .25rem .5rem; border-radius: 999px; margin: 2px; display: inline-block; font-size: .7rem; }
    .row { display: flex; gap: 1rem; }
    .legend { display: flex; gap: .5rem; flex-wrap: wrap; }
    .metric { display: inline-block; background: #f0f4ff; padding: .6rem .8rem; border-radius: .75rem; margin-right: .5rem; }
  </style>
</head>
<body>
  <h1>Next-Day Temperature Forecast Dashboard</h1>
  <div class="small">Multivariate sequence regression using an LSTM implemented in TensorFlow.js. Horizon: next-day (24h ahead) temperature prediction. Sequence length: configurable (default 48 hours).</div>
  <div class="grid" style="margin-top:1rem;">
    <div class="card" aria-label="model and input configuration">
      <h2 style="margin-top:0;">Configuration & Input</h2>
      <div class="row">
        <div style="flex:2;">
          <div class="inline">
            <div style="flex:1; min-width:160px;">
              <label for="sequence-length">Sequence length (hours)</label>
              <input id="sequence-length" type="number" value="48" min="24" max="168" />
            </div>
            <div style="flex:1; min-width:160px;">
              <label for="num-features">Number of features</label>
              <input id="num-features" type="number" value="6" min="2" max="50" />
            </div>
          </div>
          <div style="margin-top:1rem;">
            <label>Simulate or paste your past multivariate hourly data (JSON array of shape [sequence_length, num_features])</label>
            <textarea id="input-data" rows="6" placeholder='e.g. [[23.4, 12, 0.1, ...], ..., [...]]'></textarea>
            <div style="margin-top:.5rem; display:flex; gap:.5rem; flex-wrap: wrap;">
              <button id="fill-random">Fill with synthetic data</button>
              <button id="build-model">Build / Rebuild LSTM</button>
              <button id="predict">Predict Next-Day Temp</button>
            </div>
          </div>
        </div>
        <div style="flex:1;">
          <div class="metric"><div><strong>Horizon:</strong> 24h ahead</div></div>
          <div class="metric"><div><strong>Model:</strong> 1-layer LSTM + Dense</div></div>
          <div class="metric"><div><strong>Normalization:</strong> per-feature z-score (train-style)</div></div>
          <div style="margin-top:.75rem;"><label>Feature preview (names):</label>
            <div class="feature-list" id="feature-names">
              <!-- dynamic -->
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="card" aria-label="prediction output and chart">
      <h2 style="margin-top:0;">Forecast Output</h2>
      <div class="row">
        <div style="flex:2">
          <canvas id="forecast-chart" height="160"></canvas>
        </div>
        <div style="flex:1; min-width:220px;">
          <div class="metric" id="predicted-temp"><strong>Prediction:</strong> —</div>
          <div class="metric" id="confidence-interval"><strong>Uncertainty:</strong> —</div>
          <div style="margin-top:8px;"><button id="retrain">Retrain on input (mock)</button></div>
        </div>
      </div>
      <div class="small" style="margin-top:8px;">Note: This template uses synthetic normalization and no persistence store. Replace the mock training step with a backend for production.</div>
    </div>
  </div>

  <script>
    // Core parameters
    let model = null;
    let featureNames = [];
    const DEFAULT_HORIZON_HOURS = 24;

    function makeFeatureNames(n) {
      const base = ["temperature", "dust", "humidity", "pressure", "wind_speed", "pm2_5"];
      const additional = [];
      for (let i = 6; i < n; i++) additional.push(`feat${i}`);
      return base.slice(0, n).concat(additional).slice(0, n);
    }

    function updateFeatureList() {
      const n = parseInt(document.getElementById('num-features').value, 10);
      featureNames = makeFeatureNames(n);
      const container = document.getElementById('feature-names');
      container.innerHTML = '';
      featureNames.forEach(f => {
        const span = document.createElement('div');
        span.className = 'pill';
        span.textContent = f;
        container.appendChild(span);
      });
    }

    // Synthetic data generator: sequence_length x num_features
    function generateSynthetic(sequence_length, num_features) {
      // base temperature sinusoidal + noise, other features random correlated
      const data = [];
      for (let t = 0; t < sequence_length; t++) {
        const row = [];
        const temp = 20 + 5 * Math.sin(2 * Math.PI * t / 24) + Math.random() * 0.5;
        row.push(temp); // temperature
        row.push(30 + Math.random() * 10); // dust
        row.push(60 + Math.random() * 5); // humidity
        row.push(1013 + Math.random() * 2); // pressure
        row.push(3 + Math.sin(2 * Math.PI * t / 12)); // wind_speed
        row.push(Math.random() * 50); // pm2_5
        for (let i = 6; i < num_features; i++) {
          row.push(Math.random());
        }
        data.push(row);
      }
      return data;
    }

    // Simple normalization: compute mean/std on provided sequence (mock training style)
    function computeStats(sequence) {
      const arr = tf.tensor(sequence); // [seq_len, num_feat]
      const mean = arr.mean(0);
      const variance = arr.sub(mean).square().mean(0);
      const std = variance.sqrt().add(1e-6);
      return { mean, std };
    }

    function normalize(sequence, stats) {
      return tf.tidy(() => {
        const tensor = tf.tensor(sequence); // [seq_len, num_feat]
        return tensor.sub(stats.mean).div(stats.std);
      });
    }

    async function buildLSTM(sequence_length, num_features) {
      // One-layer LSTM with dropout, output dense for next-day temp (scalar)
      const input = tf.input({ shape: [sequence_length, num_features] });
      const lstm = tf.layers.lstm({ units: 64, returnSequences: false })(input);
      const dropout = tf.layers.dropout({ rate: 0.2 })(lstm);
      const dense = tf.layers.dense({ units: 32, activation: 'relu' })(dropout);
      const output = tf.layers.dense({ units: 1 })(dense); // scalar next-day temp
      const m = tf.model({ inputs: input, outputs: output });
      m.compile({ optimizer: tf.train.adam(0.001), loss: 'meanSquaredError' });
      model = m;
      console.log('Built LSTM model:', model.summary());
      alert('LSTM model built with sequence length ' + sequence_length + ' and ' + num_features + ' features.');
    }

    async function predictNextDay(sequence, stats) {
      if (!model) { alert('Build model first'); return; }
      const norm = normalize(sequence, stats); // [seq_len, num_feat]
      const batched = norm.expandDims(0); // [1, seq_len, num_feat]
      const pred = model.predict(batched); // [1,1]
      const value = (await pred.data())[0];
      // undo normalization only for temperature: assume target was temp's z-score -> approximate actual
      // Here we treated target as raw so directly use value.
      return value;
    }

    function updateChart(actual, forecast) {
      const ctx = document.getElementById('forecast-chart').getContext('2d');
      if (window._chart) window._chart.destroy();
      window._chart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: actual.map((_, i) => `T-${actual.length - i}h`).concat(['Next Day']),
          datasets: [
            { label: 'Historical temp (last seq)', data: actual, tension: 0.3, fill: false },
            { label: 'Predicted next-day temp', data: Array(actual.length).fill(null).concat([forecast]), pointBackgroundColor: '#6366f1', borderDash: [5,5], tension: 0.3 }
          ]
        },
        options: { plugins: { legend: { position: 'top' } }, scales: { y: { title: { display: true, text: 'Temperature (°C)' } } } }
      });
    }

    // Event bindings
    document.getElementById('num-features').addEventListener('input', updateFeatureList);
    document.getElementById('fill-random').addEventListener('click', () => {
      const seqLen = parseInt(document.getElementById('sequence-length').value, 10);
      const numFeat = parseInt(document.getElementById('num-features').value, 10);
      updateFeatureList();
      const synth = generateSynthetic(seqLen, numFeat);
      document.getElementById('input-data').value = JSON.stringify(synth, null, 1);
    });

    document.getElementById('build-model').addEventListener('click', async () => {
      const seqLen = parseInt(document.getElementById('sequence-length').value, 10);
      const numFeat = parseInt(document.getElementById('num-features').value, 10);
      await buildLSTM(seqLen, numFeat);
      updateFeatureList();
    });

    document.getElementById('predict').addEventListener('click', async () => {
      try {
        const seqLen = parseInt(document.getElementById('sequence-length').value, 10);
        const numFeat = parseInt(document.getElementById('num-features').value, 10);
        const raw = JSON.parse(document.getElementById('input-data').value);
        if (!Array.isArray(raw) || raw.length !== seqLen) { alert('Input must be an array of length sequence_length'); return; }
        if (!model) { alert('Build model first'); return; }
        const stats = computeStats(raw); // mock training-style normalization
        const nextTemp = await predictNextDay(raw, stats);
        document.getElementById('predicted-temp').innerHTML = `<strong>Prediction:</strong> ${nextTemp.toFixed(2)} °C`;
        document.getElementById('confidence-interval').innerHTML = `<strong>Uncertainty:</strong> ±0.5°C (placeholder)`;
        // for chart, show historical temperature (first feature) and forecast
        const historical = raw.map(r => r[0]);
        updateChart(historical, nextTemp);
      } catch (e) {
        console.error(e);
        alert('Error parsing input or running prediction.');
      }
    });

    document.getElementById('retrain').addEventListener('click', async () => {
      if (!model) { alert('Build model first'); return; }
      try {
        const seqLen = parseInt(document.getElementById('sequence-length').value, 10);
        const raw = JSON.parse(document.getElementById('input-data').value);
        const stats = computeStats(raw);
        // Mock training: train to predict next-day temperature derived from last value + sinusoidal pattern
        // Here we synthesize a pseudo-label: average of last 24 hours temp if available.
        const tempSeries = raw.map(r => r[0]);
        let target = tempSeries.slice(-24).reduce((a,b)=>a+b,0)/Math.min(24,tempSeries.length);
        const xs = normalize(raw, stats).expandDims(0); // [1, seq_len, num_feat]
        const ys = tf.tensor2d([[target]]); // shape [1,1]
        await model.fit(xs, ys, { epochs: 5, verbose: 0 });
        alert('Mock retrain complete (5 epochs)');
      } catch (e) { console.error(e); alert('Retrain failed'); }
    });

    // initialize
    updateFeatureList();
    // auto build initial model
    buildLSTM(parseInt(document.getElementById('sequence-length').value,10), parseInt(document.getElementById('num-features').value,10));
  </script>
</body>
</html>
